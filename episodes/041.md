---
title: 41 • Jack Rusher • The Aesthetics of Programming Tools
---

# 41 • Jack Rusher • The Aesthetics of Programming Tools

_07/26/2019_

<iframe src="https://omny.fm/shows/future-of-coding/41-the-aesthetics-of-programming-tools-jack-rusher/embed" width="100%" height="180" frameborder="0"></iframe>

_[Ivan Reese](http://spiralganglion.com) guest hosts._

I've been intimidated by [Jack Rusher](http://jackrusher.com) from the first blush. I mean, he's wearing a high-collared fur coat and black sunglasses in his Twitter pic, and his bio includes "Bell Labs Researcher". So when tasked with choosing a subject for my first interview, I immediately reached out to him, leaning in to my nervousness. His reply included the detail that he's "generally hostile to the form" of podcasting. Terrifying.

When we talked, it was about Lisp — several flavours of Scheme and Racket, Common Lisp, Lisp machines, Black, Clojure, parens of all stripes. It was also about aesthetics, and graphic design, the relative ignorance of typical programming tools to the capability of the visual cortex, and how to better tap it. This podcast's streak of discussions about Coq, miniKanren, TLA+, and Alloy continues, with the addition of QuickCheck and the like. Jack presents his work on a literate editor for Clojure called [Maria.cloud](https://www.maria.cloud), an environment that makes a number of unusual and interesting choices both in the design and implementation, reaching for an ideal blend of features that afford both instant beginner enthusiasm and unrestricted expert use. We pay our respects to the phenomenal red carpet that video games roll out to new players, inviting them in to the model and mechanics of the game with an apparent ease and apt ability that should be the envy of programming toolsmiths like us. The show ends with Jack sharing an excellent collection of plugs, ranging from academic papers by the relatively obscure Stéphane Conversy, to the aesthetically-lush programming tools pouring out of Hundredrabbits's Devine Lu Linvega.

I am no longer terrified of Jack's persona. Rather, I am now humbled by his towering expertise and the wildly varied accomplishments of his career, and it was a thrill to get to tour them in this interview. Best quote of the show: "A kind of grotesque capitulation to sameness." Damn, Jack!

## Links

[Jack Rusher](http://jackrusher.com) is our esteemed guest. He is on [Twitter](https://twitter.com/jackrusher), [Instagram](https://instagram.com/jackrusher), and [SoundCloud](https://soundcloud.com/jackrusher). [Applied Science](http://www.appliedscience.studio) is his consultancy, and [Maria.cloud](https://www.maria.cloud) is their beautifully designed literate Clojure editor.

[Ivan Reese](http://spiralganglion.com) hosts. He's on [Twitter](http://twitter.com/spiralganglion), works on [educational media](https://www.lunchboxsessions.com), is making a [visual programming tool](https://twitter.com/spiralganglion/status/1145028588715950080), and plays [100 instruments — badly](https://spiralganglion.bandcamp.com). He started life with [HyperCard](http://www.bbc.com/future/story/20190722-the-apple-software-that-inspired-the-internet) and now loves [Max/MSP](https://cycling74.com).

[Repl.it](https://repl.it) is our Sponsor. Email jobs@repl.it if you'd like to work on the future of coding.

[Complex Event Processing](https://en.wikipedia.org/wiki/Complex_event_processing) is a bit of technology Jack helped commercialize.

[ClojureVerse](https://clojureverse.org) is where a discussion of [Luna](https://www.luna-lang.org) led to the [Visual Programming Codex](https://github.com/ivanreese/visual-programming-codex), based on the [History of Lisp Parens](https://github.com/shaunlebron/history-of-lisp-parens) by [Shaun Lebron](https://twitter.com/shaunlebron).

[QuickCheck](https://en.wikipedia.org/wiki/QuickCheck), [miniKanren](http://minikanren.org), [Datalog](https://en.wikipedia.org/wiki/Datalog), [Black Scheme](https://www.youtube.com/watch?v=SrKj4hYic5A), and [Oleg Kiselyov](https://dl.acm.org/author_page.cfm?id=81100177557) are touched on. [Out of the Tar Pit](http://curtclifton.net/papers/MoseleyMarks06a.pdf) has its mandatory mention, and then [Chez Scheme](https://cisco.github.io/ChezScheme/) saves the day.

[Maru](https://www.piumarta.com/software/maru/) is a Project by Ian Piumarta. Maru is a symbolic expression evaluator that can compile its own implementation language. Maru is no longer maintained. [Atilla Lendvai](https://github.com/attila-lendvai/maru) made an attempt to get the project rolling, but stopped as well.

[Scheme Bricks](http://www.pawfal.org/dave/index.cgi?Projects/Scheme%20Bricks) and Media Molecule's [Dreams](http://dreams.mediamolecule.com) are interesting touchstones on the road to future visual programming languages. Ivan has an affinity for [Pure Data](https://en.wikipedia.org/wiki/Pure_Data) and [Max/MSP](https://cycling74.com) and [vvvv](https://vvvv.org).

When talking about tools for beginners versus experts, Rich Hickey's [Design, Composition, and Performance](https://www.infoq.com/presentations/Design-Composition-Performance/) is invoked — and poor [Shostakovich](https://en.wikipedia.org/wiki/Dmitri_Shostakovich).

Jack's main is [Maria.cloud](https://www.maria.cloud), named in honour of [Maria Montessori](https://en.wikipedia.org/wiki/Maria_Montessori). [SICP](https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs) gets a nod. Maria has proven useful at [Clojure Bridge](https://clojurebridge.org). [Matt Hubert](https://matt.is) [[Twitter](https://twitter.com/mhuebert)] created the [Cells](https://www.maria.cloud/cells) abstraction that Maria was eventually built atop — it's similar to [ObservableHQ](https://observablehq.com).

Video games like [Steel Battalion](https://en.wikipedia.org/wiki/Steel_Battalion), [The Witness](https://en.wikipedia.org/wiki/The_Witness_(2016_video_game)), and [Dead Space](https://en.wikipedia.org/wiki/Dead_Space_(video_game)) have strong opinions about how much, or how little, visual interface to expose to the player. Complex 3D tools like [Maya](https://en.wikipedia.org/wiki/Autodesk_Maya) and [3D Studio Max](https://en.wikipedia.org/wiki/Autodesk_3ds_Max) are GUI inspirations for Ivan, where Jack and Matt prefer simplicity, so much so that Matt wrote [When I Sit Down At My Editor, I Feel Relaxed](http://px16.matt.is). [Dave Liepmann](https://www.daveliepmann.com) is the third leg of the stool in [Applied Science](http://www.appliedscience.studio), Jack's consultancy.

Maria originally had a deployment feature like [Glitch](https://glitch.com). There's a great talk about Maria by the Applied Science trio, containing a mini-talk called [Maria for experts](https://www.youtube.com/watch?v=CUBHrS4ZzO4&start=1053) by Jack.

[Pharo](https://pharo.org) is an inspiring modern Smalltalk.

[Fructure](https://github.com/disconcision/fructure) is a wildly cool new structured editor, and its designer [Andrew Blinn](https://twitter.com/disconcision) is fantastic on Twitter.

[Extempore](https://github.com/digego/extempore) and [Temporal Recursion](http://extempore.moso.com.au/temporal_recursion.html) by Andrew Sorensen offer some interesting foundations for future visual programming tools.

[Sonic Pi](https://sonic-pi.net) and [Overtone](http://overtone.github.io) are lovely audio tools by [Sam Aaron](http://sam.aaron.name), widely praised and deservedly so, and everyone should back [Sam's Patreon](https://www.patreon.com/samaaron).

[A visual perception account of programming languages: finding the natural science in the art](https://hal.inria.fr/hal-00737414) and [Unifying Textual and Visual: A Theoretical Account of the Visual Perception of Programming Languages](https://dl.acm.org/citation.cfm?id=2661138) are obscure but beautiful papers by Stéphane Conversy.

[Aesthetic Programming](https://www.researchgate.net/publication/2517392_Aesthetic_Programming) is one of Ivan's favourites, and the author Paul Fishwick just so happened to teach Jack's graphics programming class at Uni.

[Orca](https://github.com/Hundredrabbits/Orca) is a mind-bending textual-visual-musical hybrid programming tool by [Hundredrabbits](https://github.com/Hundredrabbits), who are [Devine Lu Linvega](https://twitter.com/Neauoire) and [Rekka Bell](https://twitter.com/RekkaBell). Notwithstanding that they [live on a sailboat(!)](https://www.patreon.com/100), they do an amazing job of presenting their work and everyone in our community should take stock of how they accomplish that.

[Ableton Push](https://www.ableton.com/en/push/) and [Ableton Live](https://www.ableton.com/en/live/) are practically state-issued music tools in Berlin. (Not to mention — Ivan edited this podcast in Live, natch.)

[thi.ng](http://thi.ng) and [@thi.ng/umbrella](https://github.com/thi-ng/umbrella/) are Jurassic-scale libraries by [Karsten Schmidt](https://twitter.com/toxi), who wrote [blog posts about Clojure's Reducers in TypeScript](https://medium.com/@thi.ng/of-umbrellas-transducers-reactive-streams-mushrooms-pt-1-a8717ce3a170).

Finally, [Nextjournal](https://nextjournal.com) are doing great work with their multi-lingual online scientific notebook environment.

## Full Transcript

_Transcript sponsored by [repl.it](https://repl.it/)_

[Corrections to this transcript](https://github.com/stevekrouse/futureofcoding.org/edit/master/{{ page.path }}) are much appreciated!

<style>
  .name {
    display: inline-block;
    margin-right: 5px;
    font-weight: bold;
  }
  .time:hover {
    text-decoration: underline;
   }
  .block {
   padding-top: 10px;
  }
</style>

<div id="transcript">
  <!-- https://regexr.com/4i5k8 -->
  <div class="block">
    <div class="name">Steve:</div>
      Hello and welcome to the Future of Coding. This is Steve Krouse. Today in this episode, we are going to switch things up a bit. I was at dinner with Aidan Cunniffe and Dev Doshi a couple of months ago, and they had this wacky suggestion that I bring on a guest interviewer to take some of this podcast work off my plate, and at the same time scale it up so that there could be more conversations from different perspectives showcased on this same RSS podcast feed. I thought it was a great idea. One person immediately came to mind who would be a wonderful guest interviewer.
  </div>

  <div class="block">
    <div class="name">Steve:</div>
      <a href="http://twitter.com/spiralganglion">Ivan Reese</a> has been a listener of this podcast and part of the Future of Coding community I think since the beginning, at least that's how it feels to me. I can't remember how we originally got connected, but it's always felt like he's been there as a staunch supporter of these efforts. He's always been a really positive and encouraging voice and someone that I can always count on for sharp feedback and a thoughtful perspective.
  </div>

  <div class="block">
    <div class="name">Steve:</div>
      I have somehow come to really trust his taste on things. It's kind of a subtle thing I can't put my figure on, but I find that his aesthetic is very similar to my own, which makes him a perfect person to be a guest interviewer on this podcast.
  </div>

  <div class="block">
    <div class="name">Steve:</div>
      You actually have heard from Ivan before, you just didn't realize it. If you've enjoyed the increased audio quality in the past couple of episodes of the podcast, you have Ivan to thank. He's been in the background helping me with choosing the right microphone and getting it set up correctly. Sometimes when I set it up incorrectly, he'll help me salvage the audio quality and get the best sound that's possible given how I screwed things up. It's been a real labor of love on his part. Thanks, Ivan, for that. So without any further ado, Ivan Reese:
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      It's going to be really tough to live up to that glowing introduction that Steve gave me, but I will do my best. My name is <a href="http://spiralganglion.com">Ivan Reese</a> and I'm really excited to be on the podcast interviewing <a href="http://jackrusher.com">Jack Rusher</a>. Before we get to the interview, I will give you a whistle-stop tour of my programming career just so you know what sort of perspective I'll be bringing to the interview.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      When I was about five years old, I started making silly interactive animations and games in <a href="http://www.bbc.com/future/story/20190722-the-apple-software-that-inspired-the-internet">HyperCard</a> to annoy my sister, and I've been making silly interactive animations and games ever since.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I work for <a href="https://www.lunchboxsessions.com">a little education media company</a>. I was hired originally as a 3D animator there, though my role quickly expanded to include programming. I now make all of the frameworks and tools for the other artist-programmers in the company. My current project is <a href="https://twitter.com/spiralganglion/status/1145028588715950080">a visual programming language</a> for building interactive animations. If you follow me on <a href="http://twitter.com/spiralganglion">Twitter</a>, you know that I tweet <i>insufferably</i> about it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Outside of programming, my main hobby is music. A curious tidbit: I have a collection of over 100 different instruments all of which I <a href="https://spiralganglion.bandcamp.com">play very badly</a>. Having a hobby as a musician and being a programmer means that I've had a lot of fun exploring the intersection of those two things. <a href="https://cycling74.com">Max/MSP</a> was probably my introduction to visual programming and I still have a very soft spot in my heart for it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      So enough about me. Let me introduce <a href="http://twitter.com/jackrusher">Jack Rusher</a>, our guest on the show today. Jack is a programmer living in Berlin that I know via the Clojure community, though his interests in Lisp go way beyond that.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Jack has a fascinating history of projects that we talk about. Then we head fearlessly off into the weeds talking about logic programming, model checking, towers of abstractions, the history and future of visual programming languages, the aesthetics of programming tools, the principles of visual design that underlie all of our programming tools (whether we realize it or not), his consultancy in Berlin called <a href="http://www.appliedscience.studio">Applied Science</a>, and the programming environment that they built — a literate editor for teaching Clojure to new programmers called <a href="https://www.maria.cloud">Maria</a>.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Just before we get into the interview, I have a message to bring you from our sponsor, <a href="https://repl.it">Repl.it</a>. They sponsor the transcript of the show which you can find at <a href="https://futureofcoding.org/episodes/041">https://futureofcoding.org/episode/041</a>.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      <a href="repl.it">Repl.it</a> is an online REPL for over 30 different languages. It started out as a code playground but now scales up to a full development environment where you can do everything from deploying web servers to training ML models, all driven by the REPL. They are a small startup in San Francisco but they reach millions of programmers, students, and teachers. They're looking for hackers interested in the future of coding and making software tools more accessible and enjoyable. Email jobs@repl.it if you're interested in learning more.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Hi Jack. I'm interested in your background as a programmer, especially in your Twitter bio. You kind of teased that you had a past life as a kernel hacker at Bell Labs.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Those are actually two separate entries. When I got started with programming... Well, I started programming in the '70s on little microcomputers, 8-bit microcomputers. When I went to university, I immediately was launched in the world of VMS and Unix, specifically BSD Unix running on ridiculous refrigerator sized machines like a Gould PowerNode 9000, which is a museum piece these days, as are all the machines I was using then.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      What did that entail?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, in the beginning, the problem was that the software we were running our machines with was not particularly reliable, so we had to fix it. A great many Unix users in the mid-80s were also fixing not only userland utilities but kernel things. I went a little deeper than most, and did a lot of work particularly in file systems, virtual memory, and the scheduler in several different flavors of Unix, especially BSD variants. Ultimately in my professional life, I wrote a few different very small Unix-like operating systems that were used in embedded systems.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That's such a far cry from the programming experience that I think most people have today, where they're working on top of such a gigantic stack of abstractions that actually going down to that level is something that people do more like a spelunking expedition, rather than something that's necessary to keep the wheels turning.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Mostly hobbyists for fun these days, yeah. My GitHub even has a tiny bootloader for starting your own operating system project on x86 compatible machines that I used in a class that I taught around 2010 in New York.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah, so in some sense, you're still kind of doing that to this day.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, although my professional work at the moment is at the absolutely opposite end of the tower of abstractions.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. I'm hoping we'll get into that a little bit as the conversation goes on. So that's the kernel hacking part — what's the Bell Labs part?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For a while I was at the Labs, and our team was working on a thing that was a... The technology is called streaming databases and is sort of taking the conventional idea of a database, which is that you have a big pile of data that already exists and you ask questions about it in the form of queries and it delivers you answers based on that preexisting data... In the streaming database context, you do not yet have the data, but you do know what your question will be. You make a query in advance, and then as the data comes in, you're given something like a materialized view, or perhaps a trigger on some sort of alert or whatever, based on your query.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      In our use case, because it was AT&T, it had to do with data networking. We built a system for monitoring data traffic at a very, very large scale — because, AT&T — that would run on commodity hardware and would respond to SQL-like queries. The trick here was that we used our own modified NetBSD kernel for these machines. Then we wrote some code that would take these queries and do a complexity analysis, and take the least complicated parts and compile those into a firmware update that we would hot-flash onto the network card so that it could do a lot of the upfront processing; and then a kernel module that would do some things in kernel; and then a userspace portion that could often be scripted in Perl — because by that time there wasn't that much data left, because we had already pruned it in these faster layers further down the hardware stack.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      What era about were you working on that?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That would be not quite 20 years ago.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Oh, okay. Well in advance of the move to NoSQL databases where you have to do that similar sort of... planning out all of your queries upfront, and then kind of baking that into the data as it comes in, rather than the SQL-style collecting all the data and then querying it after the fact.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah. This is the first time that I had dealt with that particular situation in that way. But a few years later, around 2005 or 2006, I did a startup where we built a thing that kicked off the discipline called <a href="https://en.wikipedia.org/wiki/Complex_event_processing">complex event processing</a> — or rather, the commercial phase of the discipline called complex event processing, which was the same sort of idea but applied to various industrial sectors. We were a company called Aleri, which is eventually purchased by Sybase, and the product is still sold by SAP today.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      It ended up being used for all sorts of things. It was a dataflow system actually, so this is a thing that has some crossover with, I think, a general interest of the listeners of this podcast, because it had a programming mechanism that could be done through a sort of boxes-and-wires kind of approach, through a visual programming environment, or through a code approach, or through a hybrid approach where the boxes were written in a programming language of our own creation and then wired together in the visual environment.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      At one stage, this was used to handle (I think I can tell this without violating any contracts that we signed at the time) about a third of all foreign currency transactions in pound sterling, most of the anti-fraud activity for a couple of very large credit card companies (who will remain nameless), and so on and so on. It ended up being quite effective as a system for detecting patterns in data on arrival and allowing very nimble reactions to those things.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      What was the name of that technology?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The product is the Aleri Streaming Engine—
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I was more thinking the generic term, the complex event processing—
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Oh, <a href="https://en.wikipedia.org/wiki/Complex_event_processing">complex event processing</a>! It's a terrible name. We did not coin the name. It comes from the research community and it just makes it all so much scarier than it is.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I don't imagine — beyond the fact that anything to do with flowing information from one place to another is either continuous or discrete, and when it's discrete we like to call it an event, so in that sense — there's probably no relation to the event streams we have in web programming these days. Or event sourcing, rather. Is there some relation there?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, in the sense that if you have discrete events arriving and you route them through some sort of dataflow architecture, then you have something that's very like reactive programming. In our case, my two primary colleagues — who are really, really excellent designers, programmers and so on — who were working on this with me, one of them was one of the coauthors of the original adding-an-object-system-to-ML paper, and thus kicked off OCaml. He was the primary designer of the language and wrote the little VM.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      We had these little language runtimes with arena allocators that would blow away any storage that was allocated in the course of the thing so that the user wouldn't have to worry about storage allocation and so on, and with a great deal of hand optimization to the little VM. They ran really, really well. So more expert users could write these little programs in these boxes, and less... shall we say... less-expert users could then wire them together very easily, and you would have different people doing different sorts of tasks at the customer installations.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Cool. When you were describing the different ways that you could program this system, was I correct in understanding that there were three different levels? You could write traditional code; you could write little pieces of traditional code and then wire it together with some sort of visual language; and then... was there also entirely a visual language, or am I misunderstanding?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah. There was an entire visual language. In fact, that's how we started because we had believed... Or actually, it was my fault. I had believed initially that, that would be the primary way that our users would like to interface with the system. In retrospect, I feel I was wrong about that and I should have built an interface that looked more like spreadsheet. The more like Excel it would have looked, the more appropriate it would have been to the users may ended up having. I just didn't know what verticals we would end up being successful in. In finance, everybody loves a spreadsheet.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      With age, and experience in user interface design (of which I did not have that much at the time) I've come to realize that pre-post image table views would have been an excellent way to show people how to do this kind of thing.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Interesting. Just for anybody who's not familiar with that term (and I might be one of those people, though I'm imagining what I think it is): pre-post image, is that where you have one half of the view is, "Here's the data coming in," and then in the center you have, "Here's the transformation we're applying," and then on the other side you have "Here's the processed result?"
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, that's exactly it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Okay. Cool.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That would have been the much better way to do it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Right. Yeah. It's curious how, as people who are fond of visual programming in all of its different forms, we keep struggling to do something that is an order of magnitude more effective than what VisiCalc seemingly came up with right out of the gate. It's kind of frustrating how they hit upon something so seemingly fundamentally powerful very, very early on. Yet with all of our playing around with different ways of visualizing what the computer is doing, it's hard to beat just plainly showing data, and making that data and the different intermediate forms that it takes along the way very, very visible. That's hard to top.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, it's extremely powerful. Anything that taps into our evolutionary heritage I think is very strong, and that's been known at least since people like Minsky and Papert were trying to teach children with physical, mechanical turtles and things. Bringing in our intuitions — our physical intuition — is one of the strongest ways to give us a jumpstart on learning a new domain.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah, and those physical intuitions — I'm assuming you're referring to things like spatial reasoning, and something like a grid. A grid is a very knowable thing that we find in real life. Bringing that kind of a structure as a way of dealing with hierarchy, or as a way of dealing with relationships, it leverages a lot of what we bring to the computer.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Absolutely. If we push past that, if we look into other disciplines and what they've learned, one discipline that's done very well is various graphic design disciplines that have determined what axes there are really — and data visualization for that matter — have determined what axes there are really on which you can vary your presentation in order to recruit the user's visual cortex to do most of the work before their higher facilities begin to try to figure out what's happening.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      You have things like relative contrast, relative size, grouping by position in space, all of these different things. I think in programming actually, we make shamefully little use of most of these ways of conveying information to our users. In this case, users being the programmers who are using our programming tools because the tools are themselves, as you are well aware, interfaces.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. Like those fundamental design principles. You pick up any first-year college Design textbook and you won't be able to get very far into it before you encounter the fundamental building blocks of pretty much any image that is meant to convey some sort of meaning, before you get into the deeper things that are based on cultural heritage. You move through, like you said, spacing, grouping, variation in intensity and hue. What they don't even touch on — and I think something that we grossly overlook in computing — is also that there are those same fundamental building blocks available in motion.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Absolutely. Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. Entry-level design — it's not for pencil animators. So they're not learning about easing and temporal repetition and anticipation and those sorts of principles as well. For me personally, looking at a lot of the programming interfaces we have, not only are they built with a willful or accidental ignorance of design principles, but there's also this entire other domain that can be explored and leveraged to convey meaning to the programmer that's just not even been touched on.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah. Absolutely. It is a bit of a tragedy really that the editing environment continues to be... people to continue to write new editors for programming languages that offer you a grid of fixed-width type.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      It's just that's it. The paradigm is monospaced type and — oh! — we'll maybe add some color for the syntax highlighting.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. That's I think what excites me so much about the community of this podcast is... so many people here are looking at different ways of getting us from that fixed grid of colored text to <i>something</i>, and this <i>something</i> is as yet undetermined.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      It's kind of neat to see all these pieces — from the design fundamentals, or motion, or aspects of culture — being put together in different combinations to see which of them resonates most strongly with what human beings bring to the programming experience. It feels like it's unfamiliar territory, and yet we've been exploring this very territory since the 1960s, if not a lot earlier depending on how you want to frame it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Hmm.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      You have a remarkably sharp sense of aesthetics. That's something that I've noticed. From your profile picture on Twitter, to the way that you use your hobbies in programming and elsewhere and tie them together to make generative art, to being a musician, your website. Everything that I've seen you do that requires you making your presence known on the Internet is rooted in what I feel is a very strong sense of taste and cohesive sense of aesthetics.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That's why I wanted to interview you on this show, because I feel like that permeates everything you do. I imagine that it does, and so I'm curious to see, when it comes to the choices that you make in programming or your affinity for certain technologies, how do you see your own sense of aesthetics guiding those choices?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      First, I have to say thank you. Then I would say I have multiple backgrounds. I originally was educated in physics and shifted to theoretical computer science because I was seduced by certain early/mid-century findings in that discipline, and then spent a long career doing engineering with software and even a bit of hardware. When I'm doing my own programming, there is a strong pragmatic perspective for me where I will use whatever tool I feel is the one that is going to help me achieve the objective well.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      On the other hand, like everyone, I am inflicted with my own set of aesthetics that drive me toward certain things. I really, really like Scheme for example, and the closer a language is to Scheme generally the more I like it. This is one thing.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I believe that it is always better if you can to tell the computer what to do, rather than explain to it the minutia of how to do it. I find that more elegant and more pleasant, and also faster and more practical in most cases.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Is that faster in a performance sense or faster in just—
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      In a human effort extent. Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Scheme specifically? Or Lisp as a family? Or Racket?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, I've had a very enjoyable program experiences in Scheme, and in Racket, and in Common Lisp, and in some Lisp-like dialects of my own construction over the years. Yeah, generally I do enjoy parentheses I would say. But beyond that, of the group of them I feel like Scheme hit upon a distilled and crystalline vision that I respect a great deal.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      When I would use Common Lisp in the past, it was primarily because it had usually made available, at some stage some kind of very nice environment for programming. If you have listeners, for example, which I doubt with your community that you do have any listeners who aren't familiar with Common Lisp's environments — they are typically extremely humane, in the sense that if you have an error you can pause and fix the thing that broke and continue from where the error occurred, and things like this that are almost unknown in most other programming environments. So this is very, very attractive.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      But Common Lisp, the language, it's a mixed bag. There's some very nice things about it, and it also has a lot of cruft, and it doesn't have the kind of crystalline purity that Scheme does.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I think the first place we ran into each other was on the <a href="https://clojureverse.org">ClojureVerse Forum</a>. That was in a thread about the <a href="https://www.luna-lang.org">Luna language/environment</a> that had just been announced where they're creating a very Haskell-like pure functional language and also creating a very nice sort of node-and-line based visual programming environment. They're two representations of the same underlying model.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      We were looking at that environment and talking about the various merits, and projects that had tried this in the past, and some people started saying, "Hey, we should collect all of these projects <a href="https://github.com/ivanreese/visual-programming-codex">into one place</a>."
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      You suggested that somebody pull on the model of <a href="https://twitter.com/shaunlebron">Shaun Lebron</a>'s <a href="https://github.com/shaunlebron/history-of-lisp-parens">History of Lisp Parens</a>, which is this wonderful GitHub repo he made reviewing some of those beautiful environments that have been made for Lisp throughout history, and looking at not just the design of them and the choices that they've made but how they sort of—
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I feel like they were reflections of the era in which they were created, in the way that everything that is created is a reflection of its time... There was this this period through the '70s and maybe in the early '80s where it feels like the spectrum was wider. There were wilder ideas being tried, despite the fact that computing power was so much more limited back then. That the freedom to do whatever you wanted — that we have now — wasn't there back then.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      So, the scope of human ambition was curtailed by the very, very restrictive ability of the computers at the time. I feel like we haven't expanded the scope and breadth of our imagination for editing tools in lockstep with the advancement of computing power since then. I'm wondering if you also feel like the range of exploration has — if not narrowed, then at least — stayed within a known bounds. How do you see our programming culture moving forward, compared to how the technology that we built that culture on top of is moving?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I think one of the things that happened historically was that the machines that had the nicer programming environments were extremely expensive machines that essentially existed in the future relative to what people could afford at the time.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      What I mean by that is, for instance, the Lisp machine — which I had the pleasure to use a few times back in the day — was remarkable, and contained features that nothing else had. But at the same time, even back then it was a bit clunky running on — by clunky, I mean a bit slow in terms of direct response to user input — running on $80,000 worth of hardware.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      What naturally happened was cheaper, much worse workstations showed up with much worse tools and experiences available on them, but which cost such a tiny fraction of what those machines cost that it reset our expectations to what was possible on an 8088 with very little memory. That's essentially where we have stood since then, and we have professionalized the culture around the lower expectations of that lesser hardware.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Now, when we go back in time and we look at the papers from the '70s and early '80s in, for instance, the Lisp community, we find over and over again gems that were really interesting ideas that were just impractical on the hardware that most people could actually afford at the time.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      As you have pointed out just now, the hardware that you have in your phone today is far better than the hardware that one had on an extremely expensive machine in the '70s. If you're writing an environment for a modern laptop, you can do anything, which means that we are ripe for a revisiting and a rethinking of how we do these things.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Even, not only coming up with new ideas, but even performing some anthropology on the history of our own discipline and sort of cherry picking some of the great ideas that we had to leave behind because our hardware was so bad.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Alan Kay had this wonderful description: to invent the computing of the future, you can buy hardware that takes you 10 years into the future, and then you can imagine another 10 years after that. I can't remember his exact quote but it was, basically, you can put yourself 30 years into the future and work in that space if you are adequately well-funded and adequately imaginative. That ties that together, what you've said about it where... these researchers coming up with all this material were almost leaving a breadcrumb trail for people today.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Did you ever end up trying Luna?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I think I was unable to download it when I went to try it, and then I didn't go back. But I do very much like what they're doing. One of the things that I think isn't talked about enough, when people talk about languages with a strong upfront type discipline like Haskell, is that everyone focuses on this as a way to avoid making certain kinds of mistakes. But they don't really talk so much about how effective it is as a user interface paradigm, because the more the machine knows about what's possible, the better sorts of completion and filter it can give you moment-to-moment while you're editing your code.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      This is something where I think Steve — the normal host of this podcast who I am swooping in beneath — he and I really differ in this regard, in that he is very strongly of the ML-family, strongly typed persuasion and I am very dynamically of the dynamically typed, Lisp-y persuasion. I don't believe that there's anything fundamental about types and category theory that you <i>require</i> in order to create very rich tooling. Though I feel like it does... there is some cohesion there. It is very nice to have that certainty about the mathematical underpinnings of your language in order to build tooling around it. I feel sort of like there's this impression that dynamic typing leads to a very difficult foundation to build tools on top of. Though our history with Lisp would suggest otherwise.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Not only Lisp, either. I mean Smalltalk is tremendously dynamic and to this day has the best developer tools that any system can really offer. It's a ridiculous argument that you can't make good tools on top of dynamic languages.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      What I would say is that a language that has built-in a way for you to tell the environment to restrict the possibilities of a certain call site, for example, does give you the ability then to have a user interface that doesn't provide you completions that don't make any sense, for example.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Sure. Though there's no strict requirement that that be done with types. Something like specifications or contracts would work just as well. Yeah.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Oh, absolutely, absolutely. Yeah. To me, those are really fungible in terms of a way to communicate to the machine what range of possibilities they are for this call site. Anyway you can do that can work for this purpose.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Of course, for me — as I mentioned before my love of Scheme — I very much fall on the "Don't make me write all the types upfront" family of programming. Because for me, with the kind of very rich REPL-attached-to-editor kind of editing that I typically do in the dynamic languages I use, it is extremely seldom that I encounter a bug that occurred because of a bad type signature.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Those things are worked out while I'm writing the code, while I'm testing the code, while I'm evaluating the forms. I very quickly have the shape of the code the way I want it to be, and then everything is fine. I don't typically have the kinds of problems that Haskellers tell me that I would not have if I were using Haskell (which I have, in fact, used in anger in the past — and I respect Haskell a great deal, but it's not my favorite moment-to-moment programming experience).
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. The whole static-dynamic debate, it just rages on and on and on and on. I feel like it's fundamental to computation in the way that, like, we have lambda calculus, and Turing machines, and combinator calculi, and Pi-calculus, all these different fundamental models of computation. Is the static-dynamic split something that you feel like we're going to have forever and ever? Or do you feel like, in the culture, we will eventually tip one way or the other and stay there forever? Is there some kind of harmony between them we might arrive at? How do you feel about that split?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, I mean the area between the two extremes that I find most interesting is in progressive typing. Obviously, the Racket community, I think, is at the forefront of this particular approach. I do like it actually because I find that early on — and different people approach programming in different ways, but for me, if I'm encountering a new problem domain in the early phase — I tend to want to go very fast and try many different things to explore the space in an environment that helps me.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I want to evaluate lots of little forms and capture what they've produced, and their typing will exist, obviously — like if you have a vector of vectors, that's a thing and it has type. But I don't want to have to tell it that I want a vector of vectors when I'm taking apart this piece of data that's coming in off the wire in a nonce fashion from inside of Emacs just to see what kind of data I'm receiving, and so on.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      There's definitely a wide base of exploratory programming and live coding that I want to do in an extremely forgiving, extremely dynamic language. On the other hand, once something is sort of hammered-down and you are pretty sure that your need to change it is small but the cost of error is high, or alternatively — and this is something again that I feel is not talked about enough with regards to types — you need it to go very fast, then going through and providing type hints so that your compiler can do more work and produce better code becomes more valuable.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      All of that said, most of the claims for static typing in terms of avoiding errors, I find, at least in my programming life, I have gotten more mileage out of from model checkers — you know, theorem provers.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For example, if one is writing a complex protocol, this is a situation where the types can't save you but a model checker can. These are the kinds of situations in which I run into walls where, "Oops, I didn't think of that, and now a very expensive mistake has happened." Where that is much less common, at least in my programming life, as a result of not having inserted type hint somewhere.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Have you ever seen an environment that — because I'm used to seeing tools like TLA+ or Alloy as sort of separate from the actual language where the development work is being done — have you ever seen an environment that pulled those things together? Other than maybe <a href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>, or something like that.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The closest thing, really, is when you have your model checker embedded in the same language you're doing your domain programming in. So for instance Coq, for an OCaml programmer for example, feels very native relative to other ways that you might go about doing it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Is there a relationship between the sort of model checking that you've done and something that you might do with <a href="http://minikanren.org">miniKanren</a>?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      There is obviously a strong relationship between theorem provers and logic programming environments. You can, in a similar way, factor out the possibility of certain kinds of errors and so on using... Yes, obviously. You can construct a type system in a logic programming environment if you so choose. So obviously they have equivalent expressive power.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      My curiosity there is that something like miniKanren is... it's a tool that you'll reach for usually when you need to do that sort of logic programming as part of solving your domain problem. Whereas I feel like model checking is something you reach for not to reach a solution in the domain, but to reach a solution in the domain one abstraction away — the programming domain — where you're trying to figure out if the system that you're constructing to solve the domain problem has the properties that you want to imbue it with.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I'm sort of wondering aloud if there might be some kind of potential direction there for future tools to go, where they have the facilities of logic programming — like a Prolog or <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a>, miniKanren, or some sort of constraint solver — that you could use at the level of your domain problem if you need to, or you could also use it at a macro level, or... Is it <a href="https://www.youtube.com/watch?v=SrKj4hYic5A">Black Scheme</a> where you have a tower of interpreters that you build? Is that the one?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, it's the one. Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. If there's something like that. Or like a <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent typed</a> kind of environment, where the same tools that you can use at one level you can use at another level up. I don't know that I've ever seen anything like that.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I don't think... made quite so uniform, so it feels like one experience. But there are many situations where you find logic programming embedded in another programming language. That is typically how I personally prefer to use logic programming. So rather than turning to Prolog, for example, I would prefer to use miniKanren from Scheme, or, you know — <a href="https://dl.acm.org/author_page.cfm?id=81100177557">Oleg</a> has some very nice work on embedded logic programming within ML dialects, especially OCaml and so on — because I find that's actually a much nicer way to program.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      What you really want when you are solving problems is an ability to move along a kind of continuum from very declarative things, where you're at the far edge and you're essentially writing logic programs, down to extremely imperative things, where you're explaining to the computer exactly how the bytes must go in the record that you're, you know.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For example, if I'm doing graphics programming, it can be very frustrating if I have to marshal a new data structure and return it out of everyone of my functions, because the buffers that I'm moving around then are going to cross these different memory boundaries, there's going to be a lot of allocation and deallocation happening, and I'm going to have terrible performance.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      In those situations, I need to be able — if I want to write that kind of code — to drop down to a layer at which I'm just slamming bytes into a byte array. But it's not how I prefer to write most programs, right? So, optimally, ideally, I want to be able to slide back and forth along that continuum as needed, staying as far towards the declarative side as I possibly can and only dipping down into the rest as needed.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That's an idea that to me most immediately calls to mind the other, other FRP — the Functional Relational Programming idea introduced at the end of the <a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf">Out of the Tar Pit</a> paper, where they have a programming language/environment that's split into three separate pieces that each fit together — where you have one piece that is expressing relationships between entities in the system, and then another piece that is low-level, very imperative code that does performance sensitive work with the data that has those relationships, and I can't, off the top of my head, recall what the third piece of it was.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I seem to remember it was a pretty bland functional layer, wasn't it?
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah, something like that. Yeah.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's exactly what I'm talking about here... is the same thing, of course.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Well, my question is... I believe there was only ever a toy implementation of that idea brought into existence. I'm wondering what environments you've seen that do a very good job of spanning all the way from that highly declarative end of the spectrum — the logic programming end of the spectrum — all the way down to very precise control over what's in my buffers, what's being swizzled, that sort of thing.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The way that I prefer to deal with those situations is, rather than trying to make a single monolithic programming language that can do all of these things, I prefer to work in a programmable programming language that will allow me to build DSLs at these various levels of abstraction that can all work together.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For example, a good, fast Scheme implementation like <a href="https://cisco.github.io/ChezScheme/">Chez Scheme</a> with something like miniKanren to work more towards the declarative side and the ability to actually allocate a bunch of bytes and set them in a tight loop — can get the work done.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Historically, probably the environment that I found that's most agreeable for this is some of the better Common Lisp implementations because you can drill down to finding out exactly what code is being written for you by the compiler based on the code that you have written, and give type hints and do all the things you need to do at the bottom level, but you can back off and build a tower of abstractions that is as tall as you wish it to be.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      As soon as you said that, I had the thought, "Oh, of course, that's the ultimate smart-alecky answer to give on this podcast," which — I think there's a lot of the listenership who have the idea in mind that what we need is a giant comprehensive solution that spans from one end of the planet to the other — no, of course, it's Lisp! It's composition. It's small pieces that you can build your own abstractions out of. Yup. That's great.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's certainly my preference. I would say that there are other people who have been at this even longer than my ancient gray-bearded self, who prefer some of those layers to not look like Lisp. For example, this is how Alan Kay's team generally approaches any new thing, is they build a tower of languages where each language has different syntax and features relative to the language beneath it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For example, you go look at [Maru](https://www.piumarta.com/software/maru/), a very low level Lisp-like language that is used to bootstrap most of these experiments. You'll see that on top of it eventually they end up building something unsurprisingly resembling Smalltalk. Often on top of that maybe some other DSLs that are even more specialized.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The idea of course here is that if you can build a tower of DSLs and write all of the parts of your system in a language that is very agreeable for that task, that you don't need to write nearly as much code because you don't spend as much time in the awkward part of your programming language.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      So, I'm going to throw a curveball at you. (Hopefully it's a curveball.) Where have you seen, or what would you like to see, for building such towers of abstractions in a visual paradigm?
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I know you mentioned Alan Kay, and that you end up with something at the very top that looks kind of like Smalltalk. But if you're interested in having a visual experience that goes all the way from one end to the other — and you are interested in tying together those principles from graphic design and animation, and using them to get more information to and from the programmer and the computer then you'd get from just the grid of colored characters — what do you think that would look like? Or what would you want that to look like?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, I would start by saying that one of the differences I have with Alan Kay on this is that I do prefer very uniform syntax at all layers. Whereas he prefers the syntax to vary more by layer for aesthetic reasons of his own.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For me, I would want something that I could express well in a visual environment that translates across all of these domains. If I were building such a thing myself, I would maybe build it on top of Chez Scheme, but build an interface that looks something like <a href="http://www.pawfal.org/dave/index.cgi?Projects/Scheme%20Bricks">Scheme Bricks</a> or Scheme blocks, which I think is actually a kind of nice, aesthetically pleasing variation on, say, the scratch idea of blocky things plugged together kind of programming, but again with a very uniform syntax that makes it visually quite easy to see what's happening at all the different layers.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      In that sense, you would gravitate towards a visual language that is still rooted in written language rather than rooted in the language of visual arts.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, I don't think those are actually different worlds. If we study graphic design, most of it is about type. For example, I don't think that in such an environment, I would want everything to be represented by small blocks of monospaced type. We can still use vertical and horizontal alignment of elements and have them, based on what's syntactic structure they're describing, look different from each other.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      When we look at other human-scale notations for complex things, for instance traditional mathematical notation (which admittedly has many problems of its own) there are things like writing a for loop as a capital sigma with the beginning and the end at the bottom and the top and so on.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I don't see any reason why when we build, say, a map over some domain in our language that it can have a visual representation that looks like that's what it's doing. The uniformity in the sense of making everything into a little box like Scheme Bricks, that would be a starting point to bootstrap the idea, but ultimately I would like to have really beautiful typography. I would like to use all of the different things that our visual cortex can to make things more obvious to the end user as they're programming.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah, this is something where I feel like there's a lot of unexplored territory yet.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Oh! So much.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Especially as we have new projects like Media Molecule's new game <a href="http://dreams.mediamolecule.com">Dreams</a> that just came out, and VR in general as a kind of a, I would say, new frontier (that's kind of a tired term, but), it's a space that — because it is a new modality of interacting with the computer, of doing input and output — it's encouraging people to be very creative in how exactly they translate ideas from the mouse-keyboard-screen world to the VR goggles and controllers-in-your-hands world. I'm seeing a lot of very interesting ideas that are...
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      My big hobbyhorse is making execution visible. As in whatever you're doing in any language, whether it's visual or textual, the more you can do to make the programmer participatory in the execution of their program the better, in just providing their visibility into how it executes and their ability to debug things. We see some of that with Elm's time travel debugging where you can roll backwards and forward. I feel like that's a direction that we could go much, much further.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      What I'm curious about is: for the block languages, what does the future for block languages hold? I'm not necessarily asking you, I'm just putting this out there as a rhetorical kind of thing. I often wonder: to take block languages and to make them have more of the principles of graphic design and to make them leverage more human modalities and human ability, will it just be a matter of moving away from what Scratch has, where it's intended for children and it's kept very simple. But at the same time the regularity that it has is a benefit to all human beings, not just children. Would it be moving away from that for the sake of more expressivity? Or would it be something where...
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Like in Scratch, or in a block language, or Scheme Bricks, one could imagine trying to bring animation into that, and your limitations in doing that are pretty severe, I would think, in that you're not going to be necessarily moving elements around. You might be hiding or showing elements or you might be re-coloring them or you might be lighting them up to indicate some sort of a transient state that they move through as the program executes in slow motion or whatever the debugging experience is like. I sort of wonder whether that would scale all the way up to covering the whole range of what you can do with animation and graphic design or if...
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      My personal inclination is to always go for something that is in the direction of the nodes-and-lines, <a href="https://en.wikipedia.org/wiki/Pure_Data">Pure Data</a>, Smalltalk (to a certain extent) school of visual languages. Just because at that point you are in free space. You are in force-directed graph space — spit! You are in the space of having an open canvas in which to move things.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      As soon as you have an open canvas, you have not just the structured principles of design but you also have the structureless, free, artistic end of our culture that you can bring to bear on this. Of course, going in that direction means you are sacrificing a lot of that uniformity that you said that you prefer, a lot of that consistency. Or maybe not necessarily sacrificing it but, if you're bringing in the artistic cultural side of humanity, things get very subjective.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I would say this is one of the cases where I'm very happy that someone else is excited about a particular direction, because it deserves the attention, but I am not the person to give it that attention. Because thus far, I've found — and it has been a fair few of them I've played with and even a couple I've constructed — node-and-box kind of programming to be more frustrating as the complexity of the thing I'm trying to express ramps up than I'm willing to tolerate.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah, it's terrible!
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah! So for simple things it's amazing, and then it crosses a threshold much more quickly. It's like if you drew two graphs of complexity, versus writing something in Scheme, versus doing something in boxes-and-arrows, box-and-arrow starts off easier, but it crosses Scheme's increase somewhere midway along the curve and then goes to Mars.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I don't even know I'd agree that it's easier to begin with. Everybody likes to say box-and-arrow languages, "Oh, they're easy when you're working in the small, but when you're working in the large, they're a nightmare." I think they suck when you're working in the small!
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Everybody's pet example is arithmetic. Would you rather say, `(+ 2 2)` or would you rather type `n` and then `+`, and then type `n`, and then type `2`, and then drag a line from the `+` to the `2`?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, sure. In the arithmetic case, it would be terrible, but many of the situations in which I see people using this kind of programming is at a sufficiently high level of abstraction with the right kind of boxes, that they are actually primitives of sufficient power to make it pretty convenient for some simple things — especially for my friends who are designers or musicians who want to use <a href="https://cycling74.com">Max/MSP</a>, or want to use some visual node environment to do what they're doing.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      They find it less intimidating and more clear than a page of text when they start. But when their patches grow past a certain point, even they don't want to deal with it anymore because it's just too much. I find also in the data visualization side that if you have a big directed graph, it's fun to make a picture of your big directed graph, but it is not particular communicative.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      At some point, it turns into kind of <i>data art</i> and it's cool to look at, but your ability to actually reason about what it's telling you is essentially zero. It approaches zero as the number of nodes increases, right?
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's my fear about that whole school. But I definitely want other people who are excited about it to work on it and come up with something amazing.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. The idea that you are tapping into these very powerful primitives at first, and so that offers a lot of leverage to people who are artists or musicians and not programmers — I think that's the whole reason why Max/MSP and Pure Data and <a href="https://vvvv.org">vvvv</a> and all of them are as successful as they are.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, they're extremely batteries-included and that's very important. Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      To me, that seems counter to what we would actually want. As to illustrate that thought: we currently live in a world of tools that are made for beginners and pretty much exclusively for beginners. They might permit use by experts.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Rich Hickey gave <a href="https://www.infoq.com/presentations/Design-Composition-Performance/">this example</a>. When you pick up a cello, your first couple of weeks or months of playing the cello, you're going to get blisters on your fingers and it's going to be awful, strangling-a-cat kind of a sound, but you move through that initial period of great adversity to get to the point where you are a masterful cellist and you can create this transcendently beautiful music.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      The computers that we have and the software that we use are for the most part they're the ukulele. That they're very easy to pick up and strum and have a good time with, but you're not going to be playing a solo in front of a symphony orchestra doing some great <a href="https://en.wikipedia.org/wiki/Dmitri_Shostakovich">Shostakovich</a> or something like that.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That design prioritization for the novice instead of the expert... I feel like that's heightened in our programming tools especially. Because programming tools are made by programmers, and so it's the one case in computing where people are mostly allowed to scratch their own itch, where they are given the free reign to say, "Okay, For all of the other computing stuff you're building, for the operating system and the window manager and the web browser and all these sorts of things, you have to think about the person who's not a capable user of the computer."
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      But for programming tools, this is our one chance to really indulge ourselves in creating something that requires mastery. Yet we keep stumbling over that need to make things immediately adoptable by the beginner, to put in things like two-way data binding — you don't even need to worry about how data flows through your system, just say, "Point A and point B are the same, and if you change one it changes the other," and there's that magic glue between them that works great in the small and does not scale up to the large.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I wonder a lot if we've ever seen a real visual programming environment that is designed to sustain mastery rather than just cater to people who need to tap-in to batteries included power very quickly. Have you ever seen an environment like that?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      In the visual space, I think... no, although there are some that scale more gracefully than others. For example, Processing is quite approachable but you can do very sophisticated things with it. It's not a visual programming language in the sense that, say, Pure Data is, but this would be... To make something the gives you that scalability while retaining that ability to understand what you've done and not just have a massive squiggly box of things that you don't really understand how to route it anymore if you go away for two weeks. That would be a fine goal for someone building such a system.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Winding back slightly, I would characterize the situation slightly differently with regards to everything optimized for beginners. I would say instead we have this very bimodal distribution where we have the mass of computing tools are built for absolute beginners. Then we have the unapproachable beginner-hostile tools that are almost arbitrarily configurable.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      As the ultimate example of this, I have been using Emacs for 34 years. My Emacs is an amazing thing that is tuned to my exact preferences. But when I recommend it to young programmers, they frequently fool with it for a week or two and then go back to something like VS Code or whatever. Whatever the VS Code of the week is.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Do you feel like it's... There are a lot of people who, I feel like, have adopted the idea that visual programming languages as a category — not just the boxes-and-line ones, but the whole category visual programming languages — are tools exclusively for beginners, and perhaps that's related to or it's caused by the fact that they have that scalability problem. I get the sense that you don't agree with that.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah. I don't think it has to be so. I don't think it must be so. Certainly, there is that perception. I absolutely agree that there is. Part of the problem I think is that expert users who have a background in a different programming paradigm get frustrated when the expressive problem starts to happen and fall back to their other tools.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      As a consequence, they never ford forward through that sort of veil of difficulty to find what's on the other side. What you need there are some very motivated expert programmers who just want to be able to use those kinds of tools and are willing to put in the effort of figuring out a way to make them pleasant past that point.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. What would it take for you to leave Emacs behind and to use a visual programming language primarily, as your primary means of solving programming problems?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's a very good question. If I knew the answer, I would probably build that system.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      This is actually an exercise that I'm interested in working through with you, if you'll indulge me in that.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      There are some things already that I've been working on this area that we can talk about.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Sure.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      One of them is that three of us here in Berlin together tried to make an environment that would be good for beginner Clojure programmers called <a href="https://www.maria.cloud">Maria.cloud</a>. Maria, which is named after <a href="https://en.wikipedia.org/wiki/Maria_Montessori">Maria Montessori</a>, a teacher whose philosophies we found quite fetching when we were thinking about how we would approach the overall pedagogy — because it's both a programming environment and also a curriculum to get people started.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      We pirated from the best. We took the visual programming language that comes by way of both Racket and Scheme in the <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">SICP</a>-era and so forth, and some other things like this, so that we could get people started with shapes and colors and more interesting things than just adding things and finding the fixed point of some equation (which is fairly alienating for most students who don't have a mathematical background).
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      In that environment, we have done great many things to try to make shapes and controls first class objects and be able to wire them into the code. There's a dataflow library built in so that even for beginning programmers can use a thing we call <a href="https://www.maria.cloud/cells">cells</a>, which is a library patterned on spreadsheet cells.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      This allows some very nice things to be done by people with very limited programming background. We've used it to teach in a context called <a href="https://clojurebridge.org">Clojure Bridge</a>, which is an international organization that tries to get people started programming in Clojure, mostly women and people of unusual gender presentation who are underrepresented in our trade.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That thing — which we've shipped and is out in the world and that we can go and use now — is actually part of a longer-term project that we are still working on, which is to try to use it ultimately as a springboard to experiment with many different kinds of program editing. Where the underlying mechanism will be some flavor of Clojure, but the overlaid representation could be almost anything.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      We're going to try to make some more visual things in the upper layer of Maria, and have multiple possibilities, multiple views onto the same code in much the same spirit as Luna.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Very cool. That was actually one of my questions was: why is Maria a literate editor right now? What made you start with that approach?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The history of that project is that Matt, who did most of the actual day-to-day programming on the project-
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That's <a href="https://matt.is">Matt Hubert</a>?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Matt Hubert, yeah — <a href="https://twitter.com/mhuebert">available at a Twitter near you</a> — he started talking with me about this because he was very interested in trying to do something that had the power and approachability of a spreadsheet, but where the actual programming was done with a language he liked to use.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      His first project in this series of deliverables was something just called cells, which eventually became the cells library in Maria. This was a very spreadsheet-like idea where you could make little widgets using Cl- It's actually ClojureScript code because it all runs in the browser — and wire them together and write various sorts of programs.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Over time of experimenting with it, we found that something more like an IPython Notebook or like Mathematica where one could intersperse text was even more interesting because then you could share your thoughts with someone else but interspersed, drawings that are made by code that's embedded in the thing, including things that might fetch something from an API, and so forth and so on.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      We noticed when we were trying to help people learn Clojure that we could easily waste four or five hours just getting somebody's old funky laptop to get set up well enough to run a basic editor and have a JVM and run some Clojure. We thought, "Why don't we try to make this into an environment that beginners could actually use?" That's how we arrived at Maria.cloud. But then once we had that, we thought, "Well, it could be a lot of other things as well." It could be a springboard for all sorts of research into programming interfaces.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That's super cool. Yeah. I've played with Maria. The cells that underlie it, it seems like a pretty interesting dataflow model. Could you explain a little bit about how that works and what it is?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Sure. Yeah. One of the problems with notebook systems as they are often practiced is that the data flows from top to bottom when you're writing the cells, but then when you go back and change something in a cell that's higher in the document, the change doesn't flow back through.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      What tends to happen with these kinds of documents is that over time, the state that is represented in the dependent code blocks is no longer in-sync with was has happened above them, and the whole document grows less-and-less aligned with the ground truth of what's happening in that computer program/document.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      With this dataflow environment, you have a certain data type, a cell that is like a container for another kind of data type, or a box in traditional Scheme parlance, and when one of the values in one of these boxes changes, it propagates it to any other box that refers to it. So, of course, we have a graph in the background that knows what's referring to what, and we propagate the changes down through it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      You can see a very similar model in action in <a href="https://observablehq.com">ObservableHQ</a> which came out a little while later and used a more popular programming language, and it delighted me to see it. I would love to see every JavaScript programmer become more accustomed to using a sort of dataflow paradigm in these situations because it does simplify many things.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Observable, I think, is a great touchstone for people who haven't seen Maria. Though I would say for anybody who is hearing this and thinking, "Oh, I've seen literate programming before, I've played with Observable, I get the idea," one of the things that I really like about Maria is it's just pleasant to look at. I find Observable is a little bit fiddly. They've put some extra user interface around the text and it doesn't read as cleanly as I think code in Maria reads. It feels like you guys have paid extra attention to making the environment be a nice feeling space to work in, and I really appreciate that.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's back to the same design aesthetic that we try to bring to everything. The three of us have actually made a small consultancy now because we are in such violent agreement about both programming aesthetics and also visual aesthetics, and how approachable things ought to be, and how things should be presented to users.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      One of those things, which you've just touched on, is that user interfaces — I feel at least — should provide the least possible chrome. There should be no visible control that you don't need, and yet a way to get to everything that you do need.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yup. One of the topics that keeps coming up in our programming community is that we have a lot to learn from video games. I think this is one such thing. There was a period in video games where chrome was very minimal because people's experiences with video games were... they were a new field, and so we weren't ready for the Xbox controller with 20 different face buttons here. A much, much simpler period where the main interface was maybe your mouse and the screen or before that, arrow keys. Very, very limited input, very limited output.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Then we hit this point where, okay, we have all the keys on the keyboard, every one of them does something. You can hold the modifier keys and hit every key on the keyboard and that's you have your very, very sophisticated spaceship simulator.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      There was a famous Xbox game [<a href="https://en.wikipedia.org/wiki/Steel_Battalion">Steel Battalion</a>] that came with this control surface that you spread out across your lap and you had to flip open a little panel to hit the self-destruct button. In going through that exploration, as a community of game developers, we've learned that there are some experiences, some stories, or some gameplay styles that benefit tremendously from the aesthetic feeling of that complexity.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      If you are flying a spaceship, you want there to be a thousand different controls because that's part of our culture of what it is like to fly a spaceship. That's part of what makes it compelling. Then there are other experiences — puzzle games like <a href="https://en.wikipedia.org/wiki/The_Witness_(2016_video_game">The Witness</a>), or <a href="https://en.wikipedia.org/wiki/Dead_Space_(video_game">Dead Space</a>) where you're marooned on a spaceship and it's very spooky and you're all by yourself — where putting anything on the screen breaks your suspension of disbelief. It takes you out of the experience of being in the world.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I feel like that's yet another lesson that programming can learn from video games is that the choice of Chrome that we surround our tools with — its anesthetic choice, it's not just a choice about functionality. I think I skew to the opposite end that you do, where in the visual environment that I'm building I am putting in as many different buttons and control surfaces as I can because the aesthetic that I gravitate towards is that of 3D modeling tools like <a href="https://en.wikipedia.org/wiki/Autodesk_Maya">Maya</a> and <a href="https://en.wikipedia.org/wiki/Autodesk_3ds_Max">3D Studio Max</a> where they have hundreds and hundreds and hundreds of different commands.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      There is an experience you can design around that kind of an impression. It conveys, "This is a tool that you will need to invest time in learning. This is a tool that will meet that investment of time and reward it by giving you lots and lots of capability."
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Where on the Maria end of the spectrum where there's very little chrome, it has this almost meditative quality where you're meant to disappear into the experience of reading. It's meant to feel much more relaxing and enveloping rather than something that's meant to stimulate you and charge you up and say, "Okay, there's 1000 different things to do." This is meant to be soothing. I love that about it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      You've really hit upon the feeling there as well. When Matt wrote a paper about cells that he presented in, I think, 2016 at a conference in Rome, the opening paragraph was something to the effect of <a href="http://px16.matt.is">When I Sit Down At My Editor, I Feel Relaxed</a>. For him, this is the emotional space that he wishes to inhabit when he's doing work — one of serenity. That helps to direct the user interface of Maria, definitely.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That was the title of his paper, wasn't it?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      It might even have been the title.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. The other person who you are working with is <a href="https://www.daveliepmann.com">Dave Liepmann</a>
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      It is. Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. What's his role in this collective?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Dave came to us from a background working on IBM big iron for a long time after he got out of school, where he studied computer science and cognitive science and some philosophy. He fell in love with Clojure some years ago, I think maybe seven years ago now. Yeah, he's a very active part of the Berlin Clojure scene and an old friend of mine, so we all got together and we work on all of these things.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      What sort of project are you working on next or what can we can look forward to coming out of your studio? The studio is named Applied Science, is that correct?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah. The URL is <a href="http://www.appliedscience.studio">appliedscience.studio</a>. There's the grotesque plug.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Awesome. Just for the listener: the logo is so good. You should go and look at it. It's a very, very good logo.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Thank you very much for that. I did everything I could to make it look like something you would see on a piece of lab equipment in the background in 2001 Space Odyssey.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Exactly. Yup. What are you guys working on? Is it more development for Maria? Is it that visual front end? Or is it also consulting? What are you up to?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, Dave has written most of the curriculum we have now, and I think he's going to write some more curriculum for Maria. We are currently overhauling the editing experience and the underlying libraries of Maria, partially to enable us to then do the more visual programming thing.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Right now, the interface is a little too tied to parse-on-a-keystroke sort of things. We want to move to a directly-editing-the-AST sort of a thing where we serialize it out to different representations. We're pretty close to that. It's Matt doing most of that day-to-day programming on that project and it's starting to shape up and look pretty good.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      There will be a big release in terms of code changes that makes almost no difference to the day-to-day experience of choosing Maria except having fewer bugs. Then we will start rolling out experiments with it. On the side, we have a bunch of cute little things — that I won't talk about today because they're not out yet, but they are coming in the next few weeks — that are just fun toys for people to play with, with some additional source code that they can look at and learn from. Different things you can do with Clojure, different ways you can host it in the cloud, things like that.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Cool. Are those <i>unspeakable toys</i> — are they in Maria, or is this just for people who are Clojurists?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The next few things will be general purpose tools written in Clojure that are not constructed with Maria.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      One of the things we built when we first rolled out Maria to a class was a service where there was a publish button. You could write a sketch in Maria that was a fully functioning UI of some kind of program, select the cell that created the user interface, and say, "Okay. Publish this." We would spin up a web app somewhere that did a hosted version of whatever that document did, with a link back to the original. This is something like what <a href="https://glitch.com">Glitch</a> does if you've seen Glitch. The idea was that there is so much incidental complexity between a new user and writing a computer program and sharing it with their friends. Many of us are internally and intrinsically motivated to play with computers. We like solving problems, we like the things they can do for us. But many other people would love to be able to do these things if they could share them with their friends, because they're very socially embedded and they want to be able to take the things that they've made and make a friend smile with something. I felt like — and we all felt like — it would be really valuable for new users to have that experience as early as possible so that they could bootstrap them into more excitement about doing this kind of work. That will likely return sometime either late this year or early next year.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Then there is an offline experience which is a completely different thing. Not completely different; it's built on the same bones. But it will be an actual kind of environment that one can run locally and build projects with called Lark that we are building on a... lark... that will contain many of the sort of projectional editing and other sorts of features. We're all very excited about that, but it will be a little time yet until it ships.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. That's interesting. That's for — rather than Maria as it is right now, which seems sort of like an environment for learning and maybe exploring simple ideas — this would be something meant more for doing serious development?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Absolutely. Yeah. The idea is that many of the things that we've done in Maria are not specifically for beginners, they're just better ways of doing the things we do. They benefit experts as much as beginners.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      There was a presentation that we did at a Clojure conference a couple of years ago in which I did a little five minute section of the presentation on <a href="https://www.youtube.com/watch?v=CUBHrS4ZzO4&start=1053">Maria for experts</a> — just discussing how much raw power is available to someone in that environment if they already are very aware of how all these things work and do already know how to program. Our idea is to take the things that are just better for everyone and then build more tools for experts — again, that scale across skill levels, so that you don't have a sharp disconnect between things for beginners and things for experts. There's an old saying in the Unix community that you should make the easy things easy and the hard things possible. That's really one of our targets here.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Another permutation of that idea that I'm very fond of is Apple's approach to accessibility where they say, "We will do things that make the phone more usable to people who have different levels of ability, but that all of those things that we do are not specific to that person or that need. They're things that anybody might benefit from."
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Adding support for people who might need an assistive device because they don't have a lot of dexterity in their hand, for example. That same feature might benefit somebody who just wants a more comfortable way to use their iPhone. Or things that help people who might need reading glasses or something like that — the ability to adjust the text size, that might help somebody who just wants to be able to hold their phone further away.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I love that thinking of, "It's not just about enriching the beginner experience. It's that things that make something easier for beginners can be created in a way where they benefit everybody." The contrary is kind of true — where if you improve the experience for everybody in just the right way, it also makes the beginner experience better.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's exactly our target on everything that we're doing. We do not, in any sense, want to build a kind of padded chamber in which to lock the noobs. It's not that kind of project. What we're were trying to do is simultaneously make something that's good for new people and that pushes forward the possibilities for experts as well, just for better ways of doing the things that we all do day in and day out.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I met you through the Clojure community and you've talked a bit about some of the different communities that you've been a part of in your life and some of the different tools that you've worked with. Are there any language communities or programming communities or computing communities, that you're aware of, that are interesting to you, that you think people should pay more attention to? Or things from the past that you would say, "Hey, here's this paper I read and I think everybody should read it too."
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I think that there's wonderful work being done by the <a href="https://pharo.org">Pharo</a> Smalltalk people and that everyone should be paying attention to what they're doing — especially around developer tooling. It's beautiful work. I love the Racket community.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      This isn't an entire community, but there's a specific person who's doing some wonderful work on structured editing who I want to mention here. I recently (and only recently) became aware of <a href="https://github.com/disconcision/fructure">Fructure</a> by Andrew Blinn. He is <a href="https://twitter.com/disconcision">Disconcision</a> on Twitter. That work is really beautiful. It's very aesthetically motivated — very beautiful editing environment — that attempts to give you the ability to edit that you would have with plain text but in a more beautiful way in a structured editor. I recommend everybody take a look at that as well.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Another person whose work I really love is Andrew Sorensen who makes <a href="https://github.com/digego/extempore">Extempore</a>. I'm not sure how he pronounces it because I haven't heard him say it, but I read his papers and they're lovely, and the environment itself is lovely. What he's done is to create a kind of two-level Scheme language with extensions that uses LLVM to cross-compile to different hardware platforms. He's got a lower level Scheme where you have to manage your own memory and so on, but you can do all sorts of signal processing and other low level stuff in it. Then a higher level Scheme that restricts some of those things but is extremely alive as a programming environment.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      He does a lot of music with it, and he has a really great paper on something called <a href="http://extempore.moso.com.au/temporal_recursion.html">temporal recursion</a>, which we touch on in the Maria interface as well. If anybody watches the <a href="https://www.youtube.com/watch?v=CUBHrS4ZzO4&start=1053">Maria for experts sub-talk</a>, I gave an example of this where you can create a recursive function that recurses over an interval in time so that it develops and evolves over time. Then you can apply all of your normal operations to it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      For instance, you can have a random number generator that produces a random number every second, and you can send that through a temporarily recursive function that builds, eventually, a bounded sequence of the last 10 values and then turns it into a bar graph or something like this. This approach is really lovely in an environment that has a good visual layer over it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      If I'm plugging things, I always have to plug <a href="http://sam.aaron.name">Sam Aaron</a> who is doing fantastic work with <a href="https://sonic-pi.net">Sonic Pi</a>. He's a good friend of mine and he's doing amazing work and everybody should support him — monetarily — as soon as possible. Go to <a href="https://www.patreon.com/samaaron">his Patreon</a> and give him money because Sam is doing God's work.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yup. Do you know, is he still working on <a href="http://overtone.github.io">Overtone</a> at all or is that on hold just for the sake of Sonic Pi?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      He's full time Sonic Pi these days. I think a community of people have arisen who keep Overtone bouncing along.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Cool.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      There is one thing that I would love to see in the links. There was a French designer and hacker who wrote a really great paper about using the lessons from the grammar of graphics in the context of representing computer source code. I would love more people to see that paper because as far as I can tell — outside of his narrow discipline and computer scientists in his own country — it was not very widely read. It really, in a very short paper, covers the things we're talking about — about spacing, about contrast and so on.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. You shared two papers with me. One of them is a <a href="https://hal.inria.fr/hal-00737414">A visual perception account of programming languages: finding the natural science in the art</a>. Then the other one, <a href="https://dl.acm.org/citation.cfm?id=2661138">Unifying Textual and Visual: A Theoretical Account of the Visual Perception of Programming Languages</a>.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Excellent. Those are the very ones that I would love to send more people to those papers.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      On the topic of papers that we love, one of my favorite papers is by Paul Fishwick who I believe knew you ...
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, who was a professor of mine. Yeah. I wrote my first ray tracer in his graphics class in probably 1991 when I was in grad school. Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. It's a paper called <a href="https://www.researchgate.net/publication/2517392_Aesthetic_Programming">Aesthetic Programming</a>. In it, he outlines this wild idea that you can pick any kind of visual representation you want — it doesn't have to be based on those principles of design, or of animation, or anything like that; it doesn't necessarily need to have those first principles underneath it, you can pick anything — and if there's aspects about that visual representation — and I guess this would also apply to a sonic representation or whatever kind of representation you want — if there's an aspect that you can uniquely identify, you can create a mapping between that aspect and some aspect of the lambda calculus or whatever programming model you want to be working with.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I would say about that particular idea that it seems obviously true in the sense that — like what we get from Hofstadter for example about analogies as fundamental to human reasoning — if you can generate an understanding of a correlation between two things, then humans can reason about it using analogy very, very well.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      It seems to be one of the ways that we work, and also one of the ways that, for example, neural networks operate. When we train them, we can teach them correlations and even long range correlations between different kinds of patterns. I think this is something fundamental that probably terminates in information theory.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      If you think about information theory as a generalization of probability, or as its relationship to first order of Markov chains, and so on, it becomes pretty clear that that's really part of how we deal with perceptual information over time.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Whether it's glyphs on a screen or whether it's sounds we're receiving, or learning how to speak a language — maybe with no resources, you know, ending up in my country where people speak different languages picking it up on the go — these are all examples of us doing that, of inferring analogies between things across domains with very little information gone. I think it's very clear that you could start from anything.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. Whether you should is another matter entirely. Yeah, it's just such a neat idea that it's stuck out in my head all this time.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      And will you be trying to explore things along those lines in the context of some visual programming? I'd love to see the experiments.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. Unfortunately — oh hell no!
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      [Laughing] It's a big ask, I admit.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I feel like the approach that it advocates is one of: imagine any kind of depiction that you want, any kind of interface, and work from that back to the model. While I'm not a mathematician — I'm an artist — I am very amenable of the idea that you probably want to have a little bit more certainty about what your underlying model is and establish that part first, and then figure out the depiction that you want. Otherwise, you're going to end up with all sorts of red herrings and baggage from misunderstandings. It would be a lossier way of working, I feel like.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Not to throw it completely out of the window, I feel like it would be wonderful for the creation of art pieces — like, programming as an art practice rather than programming just as a way to raise venture capital money.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Which is not a very interesting objective from my perspective.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah, no, but it's the one that seems to get all the attention.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      This mention of obscure things that you learn to associate with other things in order to make art has reminded me of something that I probably would have wanted to plug before, but I definitely think you should look at, which is an audio environment for a live coding music called... I think he pronounces it <a href="https://github.com/Hundredrabbits/Orca">Orca</a>, although he does this design thing that I hate which is that the "A" in Orca is actually a lambda, and so I want to say it as "Orcl". The GitHub username is <a href="https://github.com/Hundredrabbits">Hundredrabbits</a>.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      They're fantastic.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah. Everything that they do is great. It has such a beautiful consistent aesthetic through all the tools they make. I love the way they approach everything. Yeah, this tool strikes me as something that really does come from that place of... you just have to learn to analogize the things happening on the screen to their effects over time and you get wonderful things out of it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Hundredrabbits, which is... I can't remember his last name, but.. <a href="https://twitter.com/Neauoire">Lu... Linvega</a>, something like that.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Linvega, I think, but I don't know if this is an actual name or if this is a trade... like a stage name, and I don't care.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yup, exactly.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. Him, and his partner [<a href="https://twitter.com/RekkaBell">Rekka</a>], I believe at one point they were living out of a boat.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      <a href="https://www.patreon.com/100">They're living in a sailboat.</a>
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yes, and from the sailboat they are — sustained by funds from Patreon and wherever else — just producing absolutely wonderful tools for creating art and for writing... Not writing code necessarily, but building interesting systems that do interesting things.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      They're two figures that I think that our community could learn a lot from. Not just because of their <i>incredibly</i> potent sense of aesthetics, but also their way of approaching programming as an art in itself, and as an art practice, and what that looks like. Just as a way of getting out of Silicon Valley's death grip on our field.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I think there's a lot that we can learn from looking at the past, the 1970s. There's a lot that we can learn from looking at other fields related to programming, like video games. But there's also a lot that we can learn by looking at people who are using programming... like, even the way they use GitHub is interesting and different from the way I use GitHub or the way most people use GitHub.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Their commit messages are: "*" — every commit message is an asterisk. That's an aesthetic choice. He's not going to be using `git bisect` to figure out, "Oh, yeah this is the commit where I made that change." It's something where every choice that they make about how they use the computer is a <i>marked choice</i> that is meant to be interesting for the people who are aware of the work that they're producing. It just leads to this... like, a very cohesive vision that I think is just fascinating.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I absolutely agree with you. It's not just their very well developed aesthetic sense, it's also their willingness to just come at everything from a different angle than anyone else would. To be willing to do that. Because so much of what is built is just a clone of something somebody else built with no individual agency injected into the decisions from the earliest stage. To see a team of people just go and make things that really speak to their imagination is wonderful.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Just at a practical level... So, the people listening to this show are probably thinking, "Well, that's all fine and good, but I want to make tools that people can use to solve real problems. Like we've got the climate crisis or what have you. Well, it's all good to be having fun making very, very cool character grid synthesizers that are <i>kind of programmable, but also kind of like an art toy</i>, what can <i>I</i> take away from their work?"
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I would say that one thing they excel at is making an immediate impression on people, and having a masterful degree of control around how somebody who's learning about their work for the first time comes to understand what it is.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Something I see a lot of programming tool developers struggle with is that first moment, where an audience arrives at your tool for the very first time, and they have to learn what it is that your tool does. No matter how much Material Design you clothe the webpage in, no matter how nice the rounded edges and the drop shadows behind your code samples are... I think there's a real gap between what programming tool developers think they need to say in order to sell their tools, versus how people who are encountering something for the first time need to be treated in order to really get what the tool is about.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I feel like these guys do it masterfully. Whether they're announcing tools by posting GIFs of them, so you see — since it's a thing for <i>playing with</i> — somebody playing with it. Or if it's for making music, not only are you seeing somebody making the music with it but you're hearing the music. All of their presentation, it's not a narrated video like, "This is a tool for doing X. We included these features." They make the tools really fun and playful, and then they invite you into those tools by showing you people playing with those tools and having fun. There's an immediacy to that that's missing from a lot of the stuff we do. I feel like if somebody is looking for a tangible thing to take away from them, that would be something I would look at first.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I will say two things motivated by what you've just said. One would be that I find the culture of using Bootstrap and Material Design and so on a kind of grotesque capitulation to sameness. I don't think it's actually a good thing that people have given up on the idea of improving what they can produce visually, or in terms of interaction, in exchange for not having to think about how they're going to do any of those things.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      The second thing is — to fugue it back to something we talked about before, when you were talking about video games — I think that no discipline in computing is as good at taking a new user who knows nothing about what they're about to experience, and guiding them progressively to mastery, compared to video game introductions. They don't explain. They just drop you in the world. You begin working and you learn as you go and it gives you the right hint at the right time to become an expert in playing that game.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      It's awesome to see when that goes awry. Video games that... you drop into them and they throw up five walls of text explaining, "First, you're going to click on this." Then explaining what that's going to do. It's like, "That builds your power meter and yadah-yadah-yadah." Then you click okay, and then another screen comes up and says, "After you've clicked your power meter thing and built up your mana yadah-yadah, then you have to go to the store." When tutorials in games go wrong, it's such a powerfully negative experience that it's a great way of showing by contrast how great video games normally are at this.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Totally, totally in agreement with you there. One way that I'll play devil's advocate though is that video games are very... Not only are they constrained in the domain that they span, but they also have the ability to selectively widen and narrow the domain of things you need to know about at any time. Because it's a game, they can do whatever they want.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      The very beginning of the game, they can say, "Okay, use the left thumb stick to move forward and backward." You don't have to know that later on in the game you're going to be playing the controller like it's a bassoon with fifty different fingerings. At first, it can be very, very, very simple.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I wonder, do you feel like programming tools are in some way different in that they need to be unconstrained in their domain? Or is that something that we might be able to work around as an industry, and if so, how?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      One thing we have been experimenting with in the context of <a href="https://www.maria.cloud">Maria.cloud</a> is the idea of language levels, where a new arrival to the environment might be in a simpler language level that has more informative error messages and even factors away certain extremely error-prone parts of the language.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      An example of this would be: Clojure has a great many different arities of `map`, some of which just return a function that you can pass to a reducer later. For someone who has just arrived at the language, it's a bit confusing when, what's really happened is you've forgotten to give a sequence to your map function, but what you get back is a function you don't know what to do with that is now bound to some variable. In the lowest language level, the beginner language level, we remove that arity, and then we add it back in later as the curriculum shows them more and richer things that they might do.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I think it is possible to do this kind of thing in the course of teaching a language or introducing someone to an environment. But as is obvious, because there are experts who will be frustrated by that, you have to be able to fast forward through the indoctrination.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. "Skip tutorial."
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Just to once again play devil's advocate, this sounds a little bit like it's a feature or an approach that is exclusively useful to beginners. It creates a tension against the thing we talked about earlier, about wanting to make things that are both beneficial for a beginner but also beneficial for an expert.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Do you feel that tension there, and is there a way of resolving that? Or is it just... you make the tutorial, and you skip the tutorial, and that's kind of as deep as it needs to go?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, I think that's as far as we're willing to go in terms of compromising the ability of experts in an attempt to make things better for beginners. To make special paths of learning through which they can go, that offer them a different language level, for example, or other different features. But the overall programming environment should be full-power for everyone who uses it.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Right. Sort of like <i>certain video games that shall remain nameless</i> — of which I am very, very fond, and I know certain listeners of this show will also be very fond — where, from the very beginning area of the game, you can get to the end sequence if you know just what to do in just the right way, and looking in just the right spot.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      The entire course of the game is <i>teaching you how to see</i>, so that when you arrive back at the beginning at the end of the game, you go, "Oh, there's this thing that I didn't even know how to see, that I can now see, that lets me get to the end sequence."
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That idea of... Because this is an artificial environment, and because people are going to need to be taught how to live and function in this environment — whether it's a video game, or a programming tool, or what have you — you can play those sorts of tricks where you can say, "I know that since I've created something in here that people aren't going to be familiar with, they're not going to know that it exists until I show it to them. I can use that as a way of getting through that <i>skip tutorial</i> kind of thing without actually needing the chrome of a Skip Tutorial button. People who have been here before will know that when they hold [eg] option-shift that brings up the controls for manipulating the outer shell of my environment." That sort of thing.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      There's definitely a lot we can do here to not feel these tensions between these different pushes that we have — using design, minimizing chrome, that sort of thing. But there are ways to find harmonies between them that I think have been... Video games have explored those kinds of things. The arts as well, there's lots — lots and lots — of exploration in the arts that I think would lead to similar kind of ideas.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Absolutely. I agree with everything you just said.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      I listened to some of the stuff that you've <a href="https://soundcloud.com/jackrusher">posted on SoundCloud</a>. Do you have albums that you've put together?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      <i>Back in the bygone days</i> — I don't know how old of a person you are, but perhaps when you were just a child — in the 90s, I toured with many bands and recorded with a bunch of bands and have major label releases with those, but I don't own the rights to any of that music because I had this experience that everyone does in the music industry.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      I had all the experiences of playing with... I mean, pretty much any touring artist you've heard of who is extremely famous in the '90s, I played in the band that opened for... That was what my '90s experience was like when I wasn't programming computers or competing in sports.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Yeah, all that stuff has just gone, gone, gone. But I am currently — because I'm in Berlin and it's <i>required</i> actually as part of the terms of my residence, that I create some electronic music — I've bought a <a href="https://www.ableton.com/en/push/">Push 2</a> and a couple copy of <a href="https://www.ableton.com/en/live/">Ableton Live</a>. I'm currently learning how to use that which, given that my musical training — actually, I minored in classical composition when I was at school, so it was all string quartets and things and I played in the jazz orchestra and so on — it's very analog, my music history. Now, I'm trying to make friends with these tools, and I'm absolute beginner again and I'm having a wonderful time. Probably, there will be an album of new songs sometime late this year, early next year.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Awesome. Yeah, any other plugs just while we're wrapping up the conversation?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      That's all of the stuff at the top of my mind, I'm sad to say. Probably the moment we're done, I'll remember three or four things that are desperately deserving, but that's all I've got at the moment.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      This is future Ivan. I'm just recording a followup. True to form, Jack sent me a couple of extra links right after we wrapped-up recording and I would be remiss to not include them.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      One of them — <a href="https://twitter.com/toxi">Karsten Schmidt, @toxi on Twitter</a> — he is a very, very cool programmer who works on this project called <a href="http://thi.ng">thi.ng</a>, and he has a TypeScript project called <a href="https://github.com/thi-ng/umbrella/">@thi.ng/umbrella</a>, and the original thi.ng project in Clojure is similar. They're these very, very cool, just monorepos full of resources for building computational geometry and interactive visualizations — just all sorts of wild ideas. Reading his code is like an education in itself. Jack says that Karsten has a <a href="https://medium.com/@thi.ng/of-umbrellas-transducers-reactive-streams-mushrooms-pt-1-a8717ce3a170">series of blog posts</a> discussing his take on Clojure's reducers as implemented in TypeScript that he recommends to our community.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      The one other link that he wanted to sneak in under the wire is <a href="https://nextjournal.com">Nextjournal</a>, which is Nextjournal.com. They are doing work on a multilingual online scientific notebook environment, so do go check that out as well. Now, back to your regularly scheduled programming.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      The ultimate last question that everybody asks at the end of podcasts: where can people find you on the Internet?
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      Well, I'm Jack Rusher — that is my actual name, and my username on pretty much every service you might care to find me on is my first name and my last name concatenated with no hyphen or space between. You can <a href="https://twitter.com/jackrusher">find me on Twitter</a>. If you like pictures of beautiful nature and my digital art pieces, you can <a href="https://instagram.com/jackrusher">find me on Instagram</a>. I have a website, <a href="http://jackrusher.com">jackrusher.com</a>.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Awesome. Well, Jack, thank you so much for taking the time to talk to me and to share your perspective into this field that we're all fighting against and fighting for. I really appreciate it.
  </div>

  <div class="block">
    <div class="name">Jack:</div>
      It's been a real pleasure speaking with you and I hope that we meet someday.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      Yeah. That would be great.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      That brings us to the end of the show. I hope you enjoyed it. You can find a whole bunch of other episodes of the podcast at <a href="https://futureofcoding.org/episodes">futureofcoding.org</a>. There are also links to the <a href="https://futureofcoding.org/community">Slack group</a> where a bunch of us in the programming tools and programming languages community get together, and talk about our projects, and talk about our big dreams for what the future of computing might look like.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      If you really like the podcast and you want to support it: leave a review. <a href="https://podcasts.apple.com/podcast/future-of-coding/id1265527976">Go to iTunes</a> and just say what you think, that really helps people discover the show; tweet about it; you know the deal. Another way you can support the show and the community is to back Steve on Patreon. He does a ton of legwork to organize meet-ups, to promote people in the community to his audience, and to help everyone learn from everyone else. It's a tremendous service and anything you can do to help out Steve helps out all of us.
  </div>

  <div class="block">
    <div class="name">Ivan:</div>
      If you want to get in touch with me, I am on Twitter — <a href="https://twitter.com/spiralganglion">@spiralganglion</a> (which is the nerve that connects the ear to the brain). You can of course find the show at <a href="https://futureofcoding.org">futureofcoding.org</a>. Thanks to Jack Rusher for coming on the show, and I'll see you in the future!
  </div>
</div>

<script>
// linkify each block of text with a unique ID
[].slice.call(document.querySelectorAll('.block')).map(b => b.firstElementChild).forEach((el, i) => {
  var a = document.createElement('a');
  a.href = "#" + i;
  a.name = "" + i;
  el.parentNode.insertBefore(a, el);
  a.appendChild(el);
})
</script>
